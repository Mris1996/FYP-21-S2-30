/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("@apollo/protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Trace = (function() {

    /**
     * Properties of a Trace.
     * @exports ITrace
     * @interface ITrace
     * @property {google.protobuf.ITimestamp|null} [startTime] Trace startTime
     * @property {google.protobuf.ITimestamp|null} [endTime] Trace endTime
     * @property {number|null} [durationNs] Trace durationNs
     * @property {Trace.INode|null} [root] Trace root
     * @property {string|null} [signature] Trace signature
     * @property {string|null} [unexecutedOperationBody] Trace unexecutedOperationBody
     * @property {string|null} [unexecutedOperationName] Trace unexecutedOperationName
     * @property {Trace.IDetails|null} [details] Trace details
     * @property {string|null} [clientName] Trace clientName
     * @property {string|null} [clientVersion] Trace clientVersion
     * @property {string|null} [clientAddress] Trace clientAddress
     * @property {string|null} [clientReferenceId] Trace clientReferenceId
     * @property {Trace.IHTTP|null} [http] Trace http
     * @property {Trace.ICachePolicy|null} [cachePolicy] Trace cachePolicy
     * @property {Trace.IQueryPlanNode|null} [queryPlan] Trace queryPlan
     * @property {boolean|null} [fullQueryCacheHit] Trace fullQueryCacheHit
     * @property {boolean|null} [persistedQueryHit] Trace persistedQueryHit
     * @property {boolean|null} [persistedQueryRegister] Trace persistedQueryRegister
     * @property {boolean|null} [registeredOperation] Trace registeredOperation
     * @property {boolean|null} [forbiddenOperation] Trace forbiddenOperation
     * @property {string|null} [legacySignatureNeedsResigning] Trace legacySignatureNeedsResigning
     */

    /**
     * Constructs a new Trace.
     * @exports Trace
     * @classdesc Represents a Trace.
     * @implements ITrace
     * @constructor
     * @param {ITrace=} [properties] Properties to set
     */
    function Trace(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Trace startTime.
     * @member {google.protobuf.ITimestamp|null|undefined} startTime
     * @memberof Trace
     * @instance
     */
    Trace.prototype.startTime = null;

    /**
     * Trace endTime.
     * @member {google.protobuf.ITimestamp|null|undefined} endTime
     * @memberof Trace
     * @instance
     */
    Trace.prototype.endTime = null;

    /**
     * Trace durationNs.
     * @member {number} durationNs
     * @memberof Trace
     * @instance
     */
    Trace.prototype.durationNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Trace root.
     * @member {Trace.INode|null|undefined} root
     * @memberof Trace
     * @instance
     */
    Trace.prototype.root = null;

    /**
     * Trace signature.
     * @member {string} signature
     * @memberof Trace
     * @instance
     */
    Trace.prototype.signature = "";

    /**
     * Trace unexecutedOperationBody.
     * @member {string} unexecutedOperationBody
     * @memberof Trace
     * @instance
     */
    Trace.prototype.unexecutedOperationBody = "";

    /**
     * Trace unexecutedOperationName.
     * @member {string} unexecutedOperationName
     * @memberof Trace
     * @instance
     */
    Trace.prototype.unexecutedOperationName = "";

    /**
     * Trace details.
     * @member {Trace.IDetails|null|undefined} details
     * @memberof Trace
     * @instance
     */
    Trace.prototype.details = null;

    /**
     * Trace clientName.
     * @member {string} clientName
     * @memberof Trace
     * @instance
     */
    Trace.prototype.clientName = "";

    /**
     * Trace clientVersion.
     * @member {string} clientVersion
     * @memberof Trace
     * @instance
     */
    Trace.prototype.clientVersion = "";

    /**
     * Trace clientAddress.
     * @member {string} clientAddress
     * @memberof Trace
     * @instance
     */
    Trace.prototype.clientAddress = "";

    /**
     * Trace clientReferenceId.
     * @member {string} clientReferenceId
     * @memberof Trace
     * @instance
     */
    Trace.prototype.clientReferenceId = "";

    /**
     * Trace http.
     * @member {Trace.IHTTP|null|undefined} http
     * @memberof Trace
     * @instance
     */
    Trace.prototype.http = null;

    /**
     * Trace cachePolicy.
     * @member {Trace.ICachePolicy|null|undefined} cachePolicy
     * @memberof Trace
     * @instance
     */
    Trace.prototype.cachePolicy = null;

    /**
     * Trace queryPlan.
     * @member {Trace.IQueryPlanNode|null|undefined} queryPlan
     * @memberof Trace
     * @instance
     */
    Trace.prototype.queryPlan = null;

    /**
     * Trace fullQueryCacheHit.
     * @member {boolean} fullQueryCacheHit
     * @memberof Trace
     * @instance
     */
    Trace.prototype.fullQueryCacheHit = false;

    /**
     * Trace persistedQueryHit.
     * @member {boolean} persistedQueryHit
     * @memberof Trace
     * @instance
     */
    Trace.prototype.persistedQueryHit = false;

    /**
     * Trace persistedQueryRegister.
     * @member {boolean} persistedQueryRegister
     * @memberof Trace
     * @instance
     */
    Trace.prototype.persistedQueryRegister = false;

    /**
     * Trace registeredOperation.
     * @member {boolean} registeredOperation
     * @memberof Trace
     * @instance
     */
    Trace.prototype.registeredOperation = false;

    /**
     * Trace forbiddenOperation.
     * @member {boolean} forbiddenOperation
     * @memberof Trace
     * @instance
     */
    Trace.prototype.forbiddenOperation = false;

    /**
     * Trace legacySignatureNeedsResigning.
     * @member {string} legacySignatureNeedsResigning
     * @memberof Trace
     * @instance
     */
    Trace.prototype.legacySignatureNeedsResigning = "";

    /**
     * Creates a new Trace instance using the specified properties.
     * @function create
     * @memberof Trace
     * @static
     * @param {ITrace=} [properties] Properties to set
     * @returns {Trace} Trace instance
     */
    Trace.create = function create(properties) {
        return new Trace(properties);
    };

    /**
     * Encodes the specified Trace message. Does not implicitly {@link Trace.verify|verify} messages.
     * @function encode
     * @memberof Trace
     * @static
     * @param {ITrace} message Trace message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Trace.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.legacySignatureNeedsResigning != null && Object.hasOwnProperty.call(message, "legacySignatureNeedsResigning"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.legacySignatureNeedsResigning);
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
            $root.Trace.Details.encode(message.details, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientVersion);
        if (message.clientAddress != null && Object.hasOwnProperty.call(message, "clientAddress"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientAddress);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
            $root.Trace.HTTP.encode(message.http, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
            $root.Trace.Node.encode(message.root, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
            writer.uint32(/* id 20, wireType 0 =*/160).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
            writer.uint32(/* id 22, wireType 0 =*/176).bool(message.persistedQueryRegister);
        if (message.clientReferenceId != null && Object.hasOwnProperty.call(message, "clientReferenceId"))
            writer.uint32(/* id 23, wireType 2 =*/186).string(message.clientReferenceId);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
            writer.uint32(/* id 24, wireType 0 =*/192).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
            writer.uint32(/* id 25, wireType 0 =*/200).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
            $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
            writer.uint32(/* id 27, wireType 2 =*/218).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
            writer.uint32(/* id 28, wireType 2 =*/226).string(message.unexecutedOperationName);
        return writer;
    };

    /**
     * Encodes the specified Trace message, length delimited. Does not implicitly {@link Trace.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Trace
     * @static
     * @param {ITrace} message Trace message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Trace.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Trace message from the specified reader or buffer.
     * @function decode
     * @memberof Trace
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Trace} Trace
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Trace.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 4:
                message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 3:
                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 11:
                message.durationNs = reader.uint64();
                break;
            case 14:
                message.root = $root.Trace.Node.decode(reader, reader.uint32());
                break;
            case 19:
                message.signature = reader.string();
                break;
            case 27:
                message.unexecutedOperationBody = reader.string();
                break;
            case 28:
                message.unexecutedOperationName = reader.string();
                break;
            case 6:
                message.details = $root.Trace.Details.decode(reader, reader.uint32());
                break;
            case 7:
                message.clientName = reader.string();
                break;
            case 8:
                message.clientVersion = reader.string();
                break;
            case 9:
                message.clientAddress = reader.string();
                break;
            case 23:
                message.clientReferenceId = reader.string();
                break;
            case 10:
                message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
                break;
            case 18:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
            case 26:
                message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                break;
            case 20:
                message.fullQueryCacheHit = reader.bool();
                break;
            case 21:
                message.persistedQueryHit = reader.bool();
                break;
            case 22:
                message.persistedQueryRegister = reader.bool();
                break;
            case 24:
                message.registeredOperation = reader.bool();
                break;
            case 25:
                message.forbiddenOperation = reader.bool();
                break;
            case 5:
                message.legacySignatureNeedsResigning = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Trace message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Trace
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Trace} Trace
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Trace.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Trace message.
     * @function verify
     * @memberof Trace
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Trace.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
            var error = $root.google.protobuf.Timestamp.verify(message.startTime);
            if (error)
                return "startTime." + error;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
            var error = $root.google.protobuf.Timestamp.verify(message.endTime);
            if (error)
                return "endTime." + error;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
            if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
                return "durationNs: integer|Long expected";
        if (message.root != null && message.hasOwnProperty("root")) {
            var error = $root.Trace.Node.verify(message.root);
            if (error)
                return "root." + error;
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!$util.isString(message.signature))
                return "signature: string expected";
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
            if (!$util.isString(message.unexecutedOperationBody))
                return "unexecutedOperationBody: string expected";
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
            if (!$util.isString(message.unexecutedOperationName))
                return "unexecutedOperationName: string expected";
        if (message.details != null && message.hasOwnProperty("details")) {
            var error = $root.Trace.Details.verify(message.details);
            if (error)
                return "details." + error;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
            if (!$util.isString(message.clientName))
                return "clientName: string expected";
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
            if (!$util.isString(message.clientVersion))
                return "clientVersion: string expected";
        if (message.clientAddress != null && message.hasOwnProperty("clientAddress"))
            if (!$util.isString(message.clientAddress))
                return "clientAddress: string expected";
        if (message.clientReferenceId != null && message.hasOwnProperty("clientReferenceId"))
            if (!$util.isString(message.clientReferenceId))
                return "clientReferenceId: string expected";
        if (message.http != null && message.hasOwnProperty("http")) {
            var error = $root.Trace.HTTP.verify(message.http);
            if (error)
                return "http." + error;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error)
                return "cachePolicy." + error;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
            var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);
            if (error)
                return "queryPlan." + error;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
            if (typeof message.fullQueryCacheHit !== "boolean")
                return "fullQueryCacheHit: boolean expected";
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
            if (typeof message.persistedQueryHit !== "boolean")
                return "persistedQueryHit: boolean expected";
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
            if (typeof message.persistedQueryRegister !== "boolean")
                return "persistedQueryRegister: boolean expected";
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
            if (typeof message.registeredOperation !== "boolean")
                return "registeredOperation: boolean expected";
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
            if (typeof message.forbiddenOperation !== "boolean")
                return "forbiddenOperation: boolean expected";
        if (message.legacySignatureNeedsResigning != null && message.hasOwnProperty("legacySignatureNeedsResigning"))
            if (!$util.isString(message.legacySignatureNeedsResigning))
                return "legacySignatureNeedsResigning: string expected";
        return null;
    };

    /**
     * Creates a Trace message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Trace
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Trace} Trace
     */
    Trace.fromObject = function fromObject(object) {
        if (object instanceof $root.Trace)
            return object;
        var message = new $root.Trace();
        if (object.startTime != null) {
            if (typeof object.startTime !== "object")
                throw TypeError(".Trace.startTime: object expected");
            message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
        }
        if (object.endTime != null) {
            if (typeof object.endTime !== "object")
                throw TypeError(".Trace.endTime: object expected");
            message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
        }
        if (object.durationNs != null)
            if ($util.Long)
                (message.durationNs = $util.Long.fromValue(object.durationNs)).unsigned = true;
            else if (typeof object.durationNs === "string")
                message.durationNs = parseInt(object.durationNs, 10);
            else if (typeof object.durationNs === "number")
                message.durationNs = object.durationNs;
            else if (typeof object.durationNs === "object")
                message.durationNs = new $util.LongBits(object.durationNs.low >>> 0, object.durationNs.high >>> 0).toNumber(true);
        if (object.root != null) {
            if (typeof object.root !== "object")
                throw TypeError(".Trace.root: object expected");
            message.root = $root.Trace.Node.fromObject(object.root);
        }
        if (object.signature != null)
            message.signature = String(object.signature);
        if (object.unexecutedOperationBody != null)
            message.unexecutedOperationBody = String(object.unexecutedOperationBody);
        if (object.unexecutedOperationName != null)
            message.unexecutedOperationName = String(object.unexecutedOperationName);
        if (object.details != null) {
            if (typeof object.details !== "object")
                throw TypeError(".Trace.details: object expected");
            message.details = $root.Trace.Details.fromObject(object.details);
        }
        if (object.clientName != null)
            message.clientName = String(object.clientName);
        if (object.clientVersion != null)
            message.clientVersion = String(object.clientVersion);
        if (object.clientAddress != null)
            message.clientAddress = String(object.clientAddress);
        if (object.clientReferenceId != null)
            message.clientReferenceId = String(object.clientReferenceId);
        if (object.http != null) {
            if (typeof object.http !== "object")
                throw TypeError(".Trace.http: object expected");
            message.http = $root.Trace.HTTP.fromObject(object.http);
        }
        if (object.cachePolicy != null) {
            if (typeof object.cachePolicy !== "object")
                throw TypeError(".Trace.cachePolicy: object expected");
            message.cachePolicy = $root.Trace.CachePolicy.fromObject(object.cachePolicy);
        }
        if (object.queryPlan != null) {
            if (typeof object.queryPlan !== "object")
                throw TypeError(".Trace.queryPlan: object expected");
            message.queryPlan = $root.Trace.QueryPlanNode.fromObject(object.queryPlan);
        }
        if (object.fullQueryCacheHit != null)
            message.fullQueryCacheHit = Boolean(object.fullQueryCacheHit);
        if (object.persistedQueryHit != null)
            message.persistedQueryHit = Boolean(object.persistedQueryHit);
        if (object.persistedQueryRegister != null)
            message.persistedQueryRegister = Boolean(object.persistedQueryRegister);
        if (object.registeredOperation != null)
            message.registeredOperation = Boolean(object.registeredOperation);
        if (object.forbiddenOperation != null)
            message.forbiddenOperation = Boolean(object.forbiddenOperation);
        if (object.legacySignatureNeedsResigning != null)
            message.legacySignatureNeedsResigning = String(object.legacySignatureNeedsResigning);
        return message;
    };

    /**
     * Creates a plain object from a Trace message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Trace
     * @static
     * @param {Trace} message Trace
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Trace.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.endTime = null;
            object.startTime = null;
            object.legacySignatureNeedsResigning = "";
            object.details = null;
            object.clientName = "";
            object.clientVersion = "";
            object.clientAddress = "";
            object.http = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.durationNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.durationNs = options.longs === String ? "0" : 0;
            object.root = null;
            object.cachePolicy = null;
            object.signature = "";
            object.fullQueryCacheHit = false;
            object.persistedQueryHit = false;
            object.persistedQueryRegister = false;
            object.clientReferenceId = "";
            object.registeredOperation = false;
            object.forbiddenOperation = false;
            object.queryPlan = null;
            object.unexecutedOperationBody = "";
            object.unexecutedOperationName = "";
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.legacySignatureNeedsResigning != null && message.hasOwnProperty("legacySignatureNeedsResigning"))
            object.legacySignatureNeedsResigning = message.legacySignatureNeedsResigning;
        if (message.details != null && message.hasOwnProperty("details"))
            object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
            object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
            object.clientVersion = message.clientVersion;
        if (message.clientAddress != null && message.hasOwnProperty("clientAddress"))
            object.clientAddress = message.clientAddress;
        if (message.http != null && message.hasOwnProperty("http"))
            object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
            if (typeof message.durationNs === "number")
                object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
            else
                object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
            object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
            object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
            object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
            object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.clientReferenceId != null && message.hasOwnProperty("clientReferenceId"))
            object.clientReferenceId = message.clientReferenceId;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
            object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
            object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
            object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
            object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
            object.unexecutedOperationName = message.unexecutedOperationName;
        return object;
    };

    /**
     * Converts this Trace to JSON.
     * @function toJSON
     * @memberof Trace
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Trace.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Trace.CachePolicy = (function() {

        /**
         * Properties of a CachePolicy.
         * @memberof Trace
         * @interface ICachePolicy
         * @property {Trace.CachePolicy.Scope|null} [scope] CachePolicy scope
         * @property {number|null} [maxAgeNs] CachePolicy maxAgeNs
         */

        /**
         * Constructs a new CachePolicy.
         * @memberof Trace
         * @classdesc Represents a CachePolicy.
         * @implements ICachePolicy
         * @constructor
         * @param {Trace.ICachePolicy=} [properties] Properties to set
         */
        function CachePolicy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CachePolicy scope.
         * @member {Trace.CachePolicy.Scope} scope
         * @memberof Trace.CachePolicy
         * @instance
         */
        CachePolicy.prototype.scope = 0;

        /**
         * CachePolicy maxAgeNs.
         * @member {number} maxAgeNs
         * @memberof Trace.CachePolicy
         * @instance
         */
        CachePolicy.prototype.maxAgeNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CachePolicy instance using the specified properties.
         * @function create
         * @memberof Trace.CachePolicy
         * @static
         * @param {Trace.ICachePolicy=} [properties] Properties to set
         * @returns {Trace.CachePolicy} CachePolicy instance
         */
        CachePolicy.create = function create(properties) {
            return new CachePolicy(properties);
        };

        /**
         * Encodes the specified CachePolicy message. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.
         * @function encode
         * @memberof Trace.CachePolicy
         * @static
         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CachePolicy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scope);
            if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxAgeNs);
            return writer;
        };

        /**
         * Encodes the specified CachePolicy message, length delimited. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trace.CachePolicy
         * @static
         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CachePolicy message from the specified reader or buffer.
         * @function decode
         * @memberof Trace.CachePolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trace.CachePolicy} CachePolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CachePolicy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.scope = reader.int32();
                    break;
                case 2:
                    message.maxAgeNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CachePolicy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trace.CachePolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trace.CachePolicy} CachePolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CachePolicy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CachePolicy message.
         * @function verify
         * @memberof Trace.CachePolicy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CachePolicy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.scope != null && message.hasOwnProperty("scope"))
                switch (message.scope) {
                default:
                    return "scope: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
                if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
                    return "maxAgeNs: integer|Long expected";
            return null;
        };

        /**
         * Creates a CachePolicy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trace.CachePolicy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trace.CachePolicy} CachePolicy
         */
        CachePolicy.fromObject = function fromObject(object) {
            if (object instanceof $root.Trace.CachePolicy)
                return object;
            var message = new $root.Trace.CachePolicy();
            switch (object.scope) {
            case "UNKNOWN":
            case 0:
                message.scope = 0;
                break;
            case "PUBLIC":
            case 1:
                message.scope = 1;
                break;
            case "PRIVATE":
            case 2:
                message.scope = 2;
                break;
            }
            if (object.maxAgeNs != null)
                if ($util.Long)
                    (message.maxAgeNs = $util.Long.fromValue(object.maxAgeNs)).unsigned = false;
                else if (typeof object.maxAgeNs === "string")
                    message.maxAgeNs = parseInt(object.maxAgeNs, 10);
                else if (typeof object.maxAgeNs === "number")
                    message.maxAgeNs = object.maxAgeNs;
                else if (typeof object.maxAgeNs === "object")
                    message.maxAgeNs = new $util.LongBits(object.maxAgeNs.low >>> 0, object.maxAgeNs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CachePolicy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trace.CachePolicy
         * @static
         * @param {Trace.CachePolicy} message CachePolicy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CachePolicy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.scope = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.maxAgeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxAgeNs = options.longs === String ? "0" : 0;
            }
            if (message.scope != null && message.hasOwnProperty("scope"))
                object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
            if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
                if (typeof message.maxAgeNs === "number")
                    object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
                else
                    object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
            return object;
        };

        /**
         * Converts this CachePolicy to JSON.
         * @function toJSON
         * @memberof Trace.CachePolicy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CachePolicy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Scope enum.
         * @name Trace.CachePolicy.Scope
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} PUBLIC=1 PUBLIC value
         * @property {number} PRIVATE=2 PRIVATE value
         */
        CachePolicy.Scope = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "PUBLIC"] = 1;
            values[valuesById[2] = "PRIVATE"] = 2;
            return values;
        })();

        return CachePolicy;
    })();

    Trace.Details = (function() {

        /**
         * Properties of a Details.
         * @memberof Trace
         * @interface IDetails
         * @property {Object.<string,string>|null} [variablesJson] Details variablesJson
         * @property {Object.<string,Uint8Array>|null} [deprecatedVariables] Details deprecatedVariables
         * @property {string|null} [operationName] Details operationName
         */

        /**
         * Constructs a new Details.
         * @memberof Trace
         * @classdesc Represents a Details.
         * @implements IDetails
         * @constructor
         * @param {Trace.IDetails=} [properties] Properties to set
         */
        function Details(properties) {
            this.variablesJson = {};
            this.deprecatedVariables = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Details variablesJson.
         * @member {Object.<string,string>} variablesJson
         * @memberof Trace.Details
         * @instance
         */
        Details.prototype.variablesJson = $util.emptyObject;

        /**
         * Details deprecatedVariables.
         * @member {Object.<string,Uint8Array>} deprecatedVariables
         * @memberof Trace.Details
         * @instance
         */
        Details.prototype.deprecatedVariables = $util.emptyObject;

        /**
         * Details operationName.
         * @member {string} operationName
         * @memberof Trace.Details
         * @instance
         */
        Details.prototype.operationName = "";

        /**
         * Creates a new Details instance using the specified properties.
         * @function create
         * @memberof Trace.Details
         * @static
         * @param {Trace.IDetails=} [properties] Properties to set
         * @returns {Trace.Details} Details instance
         */
        Details.create = function create(properties) {
            return new Details(properties);
        };

        /**
         * Encodes the specified Details message. Does not implicitly {@link Trace.Details.verify|verify} messages.
         * @function encode
         * @memberof Trace.Details
         * @static
         * @param {Trace.IDetails} message Details message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Details.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deprecatedVariables != null && Object.hasOwnProperty.call(message, "deprecatedVariables"))
                for (var keys = Object.keys(message.deprecatedVariables), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.deprecatedVariables[keys[i]]).ldelim();
            if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.operationName);
            if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
                for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.variablesJson[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Details message, length delimited. Does not implicitly {@link Trace.Details.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trace.Details
         * @static
         * @param {Trace.IDetails} message Details message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Details.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Details message from the specified reader or buffer.
         * @function decode
         * @memberof Trace.Details
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trace.Details} Details
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Details.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    reader.skip().pos++;
                    if (message.variablesJson === $util.emptyObject)
                        message.variablesJson = {};
                    key = reader.string();
                    reader.pos++;
                    message.variablesJson[key] = reader.string();
                    break;
                case 1:
                    reader.skip().pos++;
                    if (message.deprecatedVariables === $util.emptyObject)
                        message.deprecatedVariables = {};
                    key = reader.string();
                    reader.pos++;
                    message.deprecatedVariables[key] = reader.bytes();
                    break;
                case 3:
                    message.operationName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Details message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trace.Details
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trace.Details} Details
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Details.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Details message.
         * @function verify
         * @memberof Trace.Details
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Details.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
                if (!$util.isObject(message.variablesJson))
                    return "variablesJson: object expected";
                var key = Object.keys(message.variablesJson);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.variablesJson[key[i]]))
                        return "variablesJson: string{k:string} expected";
            }
            if (message.deprecatedVariables != null && message.hasOwnProperty("deprecatedVariables")) {
                if (!$util.isObject(message.deprecatedVariables))
                    return "deprecatedVariables: object expected";
                var key = Object.keys(message.deprecatedVariables);
                for (var i = 0; i < key.length; ++i)
                    if (!(message.deprecatedVariables[key[i]] && typeof message.deprecatedVariables[key[i]].length === "number" || $util.isString(message.deprecatedVariables[key[i]])))
                        return "deprecatedVariables: buffer{k:string} expected";
            }
            if (message.operationName != null && message.hasOwnProperty("operationName"))
                if (!$util.isString(message.operationName))
                    return "operationName: string expected";
            return null;
        };

        /**
         * Creates a Details message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trace.Details
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trace.Details} Details
         */
        Details.fromObject = function fromObject(object) {
            if (object instanceof $root.Trace.Details)
                return object;
            var message = new $root.Trace.Details();
            if (object.variablesJson) {
                if (typeof object.variablesJson !== "object")
                    throw TypeError(".Trace.Details.variablesJson: object expected");
                message.variablesJson = {};
                for (var keys = Object.keys(object.variablesJson), i = 0; i < keys.length; ++i)
                    message.variablesJson[keys[i]] = String(object.variablesJson[keys[i]]);
            }
            if (object.deprecatedVariables) {
                if (typeof object.deprecatedVariables !== "object")
                    throw TypeError(".Trace.Details.deprecatedVariables: object expected");
                message.deprecatedVariables = {};
                for (var keys = Object.keys(object.deprecatedVariables), i = 0; i < keys.length; ++i)
                    if (typeof object.deprecatedVariables[keys[i]] === "string")
                        $util.base64.decode(object.deprecatedVariables[keys[i]], message.deprecatedVariables[keys[i]] = $util.newBuffer($util.base64.length(object.deprecatedVariables[keys[i]])), 0);
                    else if (object.deprecatedVariables[keys[i]].length)
                        message.deprecatedVariables[keys[i]] = object.deprecatedVariables[keys[i]];
            }
            if (object.operationName != null)
                message.operationName = String(object.operationName);
            return message;
        };

        /**
         * Creates a plain object from a Details message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trace.Details
         * @static
         * @param {Trace.Details} message Details
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Details.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.deprecatedVariables = {};
                object.variablesJson = {};
            }
            if (options.defaults)
                object.operationName = "";
            var keys2;
            if (message.deprecatedVariables && (keys2 = Object.keys(message.deprecatedVariables)).length) {
                object.deprecatedVariables = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.deprecatedVariables[keys2[j]] = options.bytes === String ? $util.base64.encode(message.deprecatedVariables[keys2[j]], 0, message.deprecatedVariables[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedVariables[keys2[j]]) : message.deprecatedVariables[keys2[j]];
            }
            if (message.operationName != null && message.hasOwnProperty("operationName"))
                object.operationName = message.operationName;
            if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
                object.variablesJson = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this Details to JSON.
         * @function toJSON
         * @memberof Trace.Details
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Details.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Details;
    })();

    Trace.Error = (function() {

        /**
         * Properties of an Error.
         * @memberof Trace
         * @interface IError
         * @property {string|null} [message] Error message
         * @property {Array.<Trace.ILocation>|null} [location] Error location
         * @property {number|null} [timeNs] Error timeNs
         * @property {string|null} [json] Error json
         */

        /**
         * Constructs a new Error.
         * @memberof Trace
         * @classdesc Represents an Error.
         * @implements IError
         * @constructor
         * @param {Trace.IError=} [properties] Properties to set
         */
        function Error(properties) {
            this.location = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Error message.
         * @member {string} message
         * @memberof Trace.Error
         * @instance
         */
        Error.prototype.message = "";

        /**
         * Error location.
         * @member {Array.<Trace.ILocation>} location
         * @memberof Trace.Error
         * @instance
         */
        Error.prototype.location = $util.emptyArray;

        /**
         * Error timeNs.
         * @member {number} timeNs
         * @memberof Trace.Error
         * @instance
         */
        Error.prototype.timeNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Error json.
         * @member {string} json
         * @memberof Trace.Error
         * @instance
         */
        Error.prototype.json = "";

        /**
         * Creates a new Error instance using the specified properties.
         * @function create
         * @memberof Trace.Error
         * @static
         * @param {Trace.IError=} [properties] Properties to set
         * @returns {Trace.Error} Error instance
         */
        Error.create = function create(properties) {
            return new Error(properties);
        };

        /**
         * Encodes the specified Error message. Does not implicitly {@link Trace.Error.verify|verify} messages.
         * @function encode
         * @memberof Trace.Error
         * @static
         * @param {Trace.IError} message Error message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.location != null && message.location.length)
                for (var i = 0; i < message.location.length; ++i)
                    $root.Trace.Location.encode(message.location[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeNs);
            if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.json);
            return writer;
        };

        /**
         * Encodes the specified Error message, length delimited. Does not implicitly {@link Trace.Error.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trace.Error
         * @static
         * @param {Trace.IError} message Error message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Error message from the specified reader or buffer.
         * @function decode
         * @memberof Trace.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trace.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Error();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    if (!(message.location && message.location.length))
                        message.location = [];
                    message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.timeNs = reader.uint64();
                    break;
                case 4:
                    message.json = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Error message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trace.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trace.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Error message.
         * @function verify
         * @memberof Trace.Error
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Error.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.location != null && message.hasOwnProperty("location")) {
                if (!Array.isArray(message.location))
                    return "location: array expected";
                for (var i = 0; i < message.location.length; ++i) {
                    var error = $root.Trace.Location.verify(message.location[i]);
                    if (error)
                        return "location." + error;
                }
            }
            if (message.timeNs != null && message.hasOwnProperty("timeNs"))
                if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
                    return "timeNs: integer|Long expected";
            if (message.json != null && message.hasOwnProperty("json"))
                if (!$util.isString(message.json))
                    return "json: string expected";
            return null;
        };

        /**
         * Creates an Error message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trace.Error
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trace.Error} Error
         */
        Error.fromObject = function fromObject(object) {
            if (object instanceof $root.Trace.Error)
                return object;
            var message = new $root.Trace.Error();
            if (object.message != null)
                message.message = String(object.message);
            if (object.location) {
                if (!Array.isArray(object.location))
                    throw TypeError(".Trace.Error.location: array expected");
                message.location = [];
                for (var i = 0; i < object.location.length; ++i) {
                    if (typeof object.location[i] !== "object")
                        throw TypeError(".Trace.Error.location: object expected");
                    message.location[i] = $root.Trace.Location.fromObject(object.location[i]);
                }
            }
            if (object.timeNs != null)
                if ($util.Long)
                    (message.timeNs = $util.Long.fromValue(object.timeNs)).unsigned = true;
                else if (typeof object.timeNs === "string")
                    message.timeNs = parseInt(object.timeNs, 10);
                else if (typeof object.timeNs === "number")
                    message.timeNs = object.timeNs;
                else if (typeof object.timeNs === "object")
                    message.timeNs = new $util.LongBits(object.timeNs.low >>> 0, object.timeNs.high >>> 0).toNumber(true);
            if (object.json != null)
                message.json = String(object.json);
            return message;
        };

        /**
         * Creates a plain object from an Error message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trace.Error
         * @static
         * @param {Trace.Error} message Error
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Error.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.location = [];
            if (options.defaults) {
                object.message = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeNs = options.longs === String ? "0" : 0;
                object.json = "";
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.location && message.location.length) {
                object.location = [];
                for (var j = 0; j < message.location.length; ++j)
                    object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
            }
            if (message.timeNs != null && message.hasOwnProperty("timeNs"))
                if (typeof message.timeNs === "number")
                    object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
                else
                    object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
            if (message.json != null && message.hasOwnProperty("json"))
                object.json = message.json;
            return object;
        };

        /**
         * Converts this Error to JSON.
         * @function toJSON
         * @memberof Trace.Error
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Error.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Error;
    })();

    Trace.HTTP = (function() {

        /**
         * Properties of a HTTP.
         * @memberof Trace
         * @interface IHTTP
         * @property {Trace.HTTP.Method|null} [method] HTTP method
         * @property {string|null} [host] HTTP host
         * @property {string|null} [path] HTTP path
         * @property {Object.<string,Trace.HTTP.IValues>|null} [requestHeaders] HTTP requestHeaders
         * @property {Object.<string,Trace.HTTP.IValues>|null} [responseHeaders] HTTP responseHeaders
         * @property {number|null} [statusCode] HTTP statusCode
         * @property {boolean|null} [secure] HTTP secure
         * @property {string|null} [protocol] HTTP protocol
         */

        /**
         * Constructs a new HTTP.
         * @memberof Trace
         * @classdesc Represents a HTTP.
         * @implements IHTTP
         * @constructor
         * @param {Trace.IHTTP=} [properties] Properties to set
         */
        function HTTP(properties) {
            this.requestHeaders = {};
            this.responseHeaders = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HTTP method.
         * @member {Trace.HTTP.Method} method
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.method = 0;

        /**
         * HTTP host.
         * @member {string} host
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.host = "";

        /**
         * HTTP path.
         * @member {string} path
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.path = "";

        /**
         * HTTP requestHeaders.
         * @member {Object.<string,Trace.HTTP.IValues>} requestHeaders
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.requestHeaders = $util.emptyObject;

        /**
         * HTTP responseHeaders.
         * @member {Object.<string,Trace.HTTP.IValues>} responseHeaders
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.responseHeaders = $util.emptyObject;

        /**
         * HTTP statusCode.
         * @member {number} statusCode
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.statusCode = 0;

        /**
         * HTTP secure.
         * @member {boolean} secure
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.secure = false;

        /**
         * HTTP protocol.
         * @member {string} protocol
         * @memberof Trace.HTTP
         * @instance
         */
        HTTP.prototype.protocol = "";

        /**
         * Creates a new HTTP instance using the specified properties.
         * @function create
         * @memberof Trace.HTTP
         * @static
         * @param {Trace.IHTTP=} [properties] Properties to set
         * @returns {Trace.HTTP} HTTP instance
         */
        HTTP.create = function create(properties) {
            return new HTTP(properties);
        };

        /**
         * Encodes the specified HTTP message. Does not implicitly {@link Trace.HTTP.verify|verify} messages.
         * @function encode
         * @memberof Trace.HTTP
         * @static
         * @param {Trace.IHTTP} message HTTP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTTP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);
            if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
                for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
                for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.statusCode);
            if (message.secure != null && Object.hasOwnProperty.call(message, "secure"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.secure);
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.protocol);
            return writer;
        };

        /**
         * Encodes the specified HTTP message, length delimited. Does not implicitly {@link Trace.HTTP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trace.HTTP
         * @static
         * @param {Trace.IHTTP} message HTTP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTTP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HTTP message from the specified reader or buffer.
         * @function decode
         * @memberof Trace.HTTP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trace.HTTP} HTTP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTTP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.method = reader.int32();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                case 3:
                    message.path = reader.string();
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.requestHeaders === $util.emptyObject)
                        message.requestHeaders = {};
                    key = reader.string();
                    reader.pos++;
                    message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                    break;
                case 5:
                    reader.skip().pos++;
                    if (message.responseHeaders === $util.emptyObject)
                        message.responseHeaders = {};
                    key = reader.string();
                    reader.pos++;
                    message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.statusCode = reader.uint32();
                    break;
                case 8:
                    message.secure = reader.bool();
                    break;
                case 9:
                    message.protocol = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HTTP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trace.HTTP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trace.HTTP} HTTP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTTP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HTTP message.
         * @function verify
         * @memberof Trace.HTTP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HTTP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
                if (!$util.isObject(message.requestHeaders))
                    return "requestHeaders: object expected";
                var key = Object.keys(message.requestHeaders);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
                    if (error)
                        return "requestHeaders." + error;
                }
            }
            if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
                if (!$util.isObject(message.responseHeaders))
                    return "responseHeaders: object expected";
                var key = Object.keys(message.responseHeaders);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
                    if (error)
                        return "responseHeaders." + error;
                }
            }
            if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                if (!$util.isInteger(message.statusCode))
                    return "statusCode: integer expected";
            if (message.secure != null && message.hasOwnProperty("secure"))
                if (typeof message.secure !== "boolean")
                    return "secure: boolean expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isString(message.protocol))
                    return "protocol: string expected";
            return null;
        };

        /**
         * Creates a HTTP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trace.HTTP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trace.HTTP} HTTP
         */
        HTTP.fromObject = function fromObject(object) {
            if (object instanceof $root.Trace.HTTP)
                return object;
            var message = new $root.Trace.HTTP();
            switch (object.method) {
            case "UNKNOWN":
            case 0:
                message.method = 0;
                break;
            case "OPTIONS":
            case 1:
                message.method = 1;
                break;
            case "GET":
            case 2:
                message.method = 2;
                break;
            case "HEAD":
            case 3:
                message.method = 3;
                break;
            case "POST":
            case 4:
                message.method = 4;
                break;
            case "PUT":
            case 5:
                message.method = 5;
                break;
            case "DELETE":
            case 6:
                message.method = 6;
                break;
            case "TRACE":
            case 7:
                message.method = 7;
                break;
            case "CONNECT":
            case 8:
                message.method = 8;
                break;
            case "PATCH":
            case 9:
                message.method = 9;
                break;
            }
            if (object.host != null)
                message.host = String(object.host);
            if (object.path != null)
                message.path = String(object.path);
            if (object.requestHeaders) {
                if (typeof object.requestHeaders !== "object")
                    throw TypeError(".Trace.HTTP.requestHeaders: object expected");
                message.requestHeaders = {};
                for (var keys = Object.keys(object.requestHeaders), i = 0; i < keys.length; ++i) {
                    if (typeof object.requestHeaders[keys[i]] !== "object")
                        throw TypeError(".Trace.HTTP.requestHeaders: object expected");
                    message.requestHeaders[keys[i]] = $root.Trace.HTTP.Values.fromObject(object.requestHeaders[keys[i]]);
                }
            }
            if (object.responseHeaders) {
                if (typeof object.responseHeaders !== "object")
                    throw TypeError(".Trace.HTTP.responseHeaders: object expected");
                message.responseHeaders = {};
                for (var keys = Object.keys(object.responseHeaders), i = 0; i < keys.length; ++i) {
                    if (typeof object.responseHeaders[keys[i]] !== "object")
                        throw TypeError(".Trace.HTTP.responseHeaders: object expected");
                    message.responseHeaders[keys[i]] = $root.Trace.HTTP.Values.fromObject(object.responseHeaders[keys[i]]);
                }
            }
            if (object.statusCode != null)
                message.statusCode = object.statusCode >>> 0;
            if (object.secure != null)
                message.secure = Boolean(object.secure);
            if (object.protocol != null)
                message.protocol = String(object.protocol);
            return message;
        };

        /**
         * Creates a plain object from a HTTP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trace.HTTP
         * @static
         * @param {Trace.HTTP} message HTTP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HTTP.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.requestHeaders = {};
                object.responseHeaders = {};
            }
            if (options.defaults) {
                object.method = options.enums === String ? "UNKNOWN" : 0;
                object.host = "";
                object.path = "";
                object.statusCode = 0;
                object.secure = false;
                object.protocol = "";
            }
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            var keys2;
            if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
                object.requestHeaders = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
            }
            if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
                object.responseHeaders = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
            }
            if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                object.statusCode = message.statusCode;
            if (message.secure != null && message.hasOwnProperty("secure"))
                object.secure = message.secure;
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            return object;
        };

        /**
         * Converts this HTTP to JSON.
         * @function toJSON
         * @memberof Trace.HTTP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HTTP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        HTTP.Values = (function() {

            /**
             * Properties of a Values.
             * @memberof Trace.HTTP
             * @interface IValues
             * @property {Array.<string>|null} [value] Values value
             */

            /**
             * Constructs a new Values.
             * @memberof Trace.HTTP
             * @classdesc Represents a Values.
             * @implements IValues
             * @constructor
             * @param {Trace.HTTP.IValues=} [properties] Properties to set
             */
            function Values(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Values value.
             * @member {Array.<string>} value
             * @memberof Trace.HTTP.Values
             * @instance
             */
            Values.prototype.value = $util.emptyArray;

            /**
             * Creates a new Values instance using the specified properties.
             * @function create
             * @memberof Trace.HTTP.Values
             * @static
             * @param {Trace.HTTP.IValues=} [properties] Properties to set
             * @returns {Trace.HTTP.Values} Values instance
             */
            Values.create = function create(properties) {
                return new Values(properties);
            };

            /**
             * Encodes the specified Values message. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.
             * @function encode
             * @memberof Trace.HTTP.Values
             * @static
             * @param {Trace.HTTP.IValues} message Values message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Values.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);
                return writer;
            };

            /**
             * Encodes the specified Values message, length delimited. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Trace.HTTP.Values
             * @static
             * @param {Trace.HTTP.IValues} message Values message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Values.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Values message from the specified reader or buffer.
             * @function decode
             * @memberof Trace.HTTP.Values
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Trace.HTTP.Values} Values
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Values.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Values message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Trace.HTTP.Values
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Trace.HTTP.Values} Values
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Values.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Values message.
             * @function verify
             * @memberof Trace.HTTP.Values
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Values.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isString(message.value[i]))
                            return "value: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Values message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Trace.HTTP.Values
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Trace.HTTP.Values} Values
             */
            Values.fromObject = function fromObject(object) {
                if (object instanceof $root.Trace.HTTP.Values)
                    return object;
                var message = new $root.Trace.HTTP.Values();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".Trace.HTTP.Values.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        message.value[i] = String(object.value[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Values message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Trace.HTTP.Values
             * @static
             * @param {Trace.HTTP.Values} message Values
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Values.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = message.value[j];
                }
                return object;
            };

            /**
             * Converts this Values to JSON.
             * @function toJSON
             * @memberof Trace.HTTP.Values
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Values.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Values;
        })();

        /**
         * Method enum.
         * @name Trace.HTTP.Method
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OPTIONS=1 OPTIONS value
         * @property {number} GET=2 GET value
         * @property {number} HEAD=3 HEAD value
         * @property {number} POST=4 POST value
         * @property {number} PUT=5 PUT value
         * @property {number} DELETE=6 DELETE value
         * @property {number} TRACE=7 TRACE value
         * @property {number} CONNECT=8 CONNECT value
         * @property {number} PATCH=9 PATCH value
         */
        HTTP.Method = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OPTIONS"] = 1;
            values[valuesById[2] = "GET"] = 2;
            values[valuesById[3] = "HEAD"] = 3;
            values[valuesById[4] = "POST"] = 4;
            values[valuesById[5] = "PUT"] = 5;
            values[valuesById[6] = "DELETE"] = 6;
            values[valuesById[7] = "TRACE"] = 7;
            values[valuesById[8] = "CONNECT"] = 8;
            values[valuesById[9] = "PATCH"] = 9;
            return values;
        })();

        return HTTP;
    })();

    Trace.Location = (function() {

        /**
         * Properties of a Location.
         * @memberof Trace
         * @interface ILocation
         * @property {number|null} [line] Location line
         * @property {number|null} [column] Location column
         */

        /**
         * Constructs a new Location.
         * @memberof Trace
         * @classdesc Represents a Location.
         * @implements ILocation
         * @constructor
         * @param {Trace.ILocation=} [properties] Properties to set
         */
        function Location(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Location line.
         * @member {number} line
         * @memberof Trace.Location
         * @instance
         */
        Location.prototype.line = 0;

        /**
         * Location column.
         * @member {number} column
         * @memberof Trace.Location
         * @instance
         */
        Location.prototype.column = 0;

        /**
         * Creates a new Location instance using the specified properties.
         * @function create
         * @memberof Trace.Location
         * @static
         * @param {Trace.ILocation=} [properties] Properties to set
         * @returns {Trace.Location} Location instance
         */
        Location.create = function create(properties) {
            return new Location(properties);
        };

        /**
         * Encodes the specified Location message. Does not implicitly {@link Trace.Location.verify|verify} messages.
         * @function encode
         * @memberof Trace.Location
         * @static
         * @param {Trace.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.line);
            if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);
            return writer;
        };

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link Trace.Location.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trace.Location
         * @static
         * @param {Trace.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @function decode
         * @memberof Trace.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trace.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Location();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.line = reader.uint32();
                    break;
                case 2:
                    message.column = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trace.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trace.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Location message.
         * @function verify
         * @memberof Trace.Location
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Location.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.line != null && message.hasOwnProperty("line"))
                if (!$util.isInteger(message.line))
                    return "line: integer expected";
            if (message.column != null && message.hasOwnProperty("column"))
                if (!$util.isInteger(message.column))
                    return "column: integer expected";
            return null;
        };

        /**
         * Creates a Location message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trace.Location
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trace.Location} Location
         */
        Location.fromObject = function fromObject(object) {
            if (object instanceof $root.Trace.Location)
                return object;
            var message = new $root.Trace.Location();
            if (object.line != null)
                message.line = object.line >>> 0;
            if (object.column != null)
                message.column = object.column >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trace.Location
         * @static
         * @param {Trace.Location} message Location
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Location.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.line = 0;
                object.column = 0;
            }
            if (message.line != null && message.hasOwnProperty("line"))
                object.line = message.line;
            if (message.column != null && message.hasOwnProperty("column"))
                object.column = message.column;
            return object;
        };

        /**
         * Converts this Location to JSON.
         * @function toJSON
         * @memberof Trace.Location
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Location.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Location;
    })();

    Trace.Node = (function() {

        /**
         * Properties of a Node.
         * @memberof Trace
         * @interface INode
         * @property {string|null} [responseName] Node responseName
         * @property {number|null} [index] Node index
         * @property {string|null} [originalFieldName] Node originalFieldName
         * @property {string|null} [type] Node type
         * @property {string|null} [parentType] Node parentType
         * @property {Trace.ICachePolicy|null} [cachePolicy] Node cachePolicy
         * @property {number|null} [startTime] Node startTime
         * @property {number|null} [endTime] Node endTime
         * @property {Array.<Trace.IError>|null} [error] Node error
         * @property {Array.<Trace.INode>|null} [child] Node child
         */

        /**
         * Constructs a new Node.
         * @memberof Trace
         * @classdesc Represents a Node.
         * @implements INode
         * @constructor
         * @param {Trace.INode=} [properties] Properties to set
         */
        function Node(properties) {
            this.error = [];
            this.child = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Node responseName.
         * @member {string} responseName
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.responseName = "";

        /**
         * Node index.
         * @member {number} index
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.index = 0;

        /**
         * Node originalFieldName.
         * @member {string} originalFieldName
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.originalFieldName = "";

        /**
         * Node type.
         * @member {string} type
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.type = "";

        /**
         * Node parentType.
         * @member {string} parentType
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.parentType = "";

        /**
         * Node cachePolicy.
         * @member {Trace.ICachePolicy|null|undefined} cachePolicy
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.cachePolicy = null;

        /**
         * Node startTime.
         * @member {number} startTime
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Node endTime.
         * @member {number} endTime
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Node error.
         * @member {Array.<Trace.IError>} error
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.error = $util.emptyArray;

        /**
         * Node child.
         * @member {Array.<Trace.INode>} child
         * @memberof Trace.Node
         * @instance
         */
        Node.prototype.child = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Node id.
         * @member {"responseName"|"index"|undefined} id
         * @memberof Trace.Node
         * @instance
         */
        Object.defineProperty(Node.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Node instance using the specified properties.
         * @function create
         * @memberof Trace.Node
         * @static
         * @param {Trace.INode=} [properties] Properties to set
         * @returns {Trace.Node} Node instance
         */
        Node.create = function create(properties) {
            return new Node(properties);
        };

        /**
         * Encodes the specified Node message. Does not implicitly {@link Trace.Node.verify|verify} messages.
         * @function encode
         * @memberof Trace.Node
         * @static
         * @param {Trace.INode} message Node message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Node.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.responseName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
            if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
                $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.endTime);
            if (message.error != null && message.error.length)
                for (var i = 0; i < message.error.length; ++i)
                    $root.Trace.Error.encode(message.error[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.child != null && message.child.length)
                for (var i = 0; i < message.child.length; ++i)
                    $root.Trace.Node.encode(message.child[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentType);
            if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.originalFieldName);
            return writer;
        };

        /**
         * Encodes the specified Node message, length delimited. Does not implicitly {@link Trace.Node.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trace.Node
         * @static
         * @param {Trace.INode} message Node message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Node.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Node message from the specified reader or buffer.
         * @function decode
         * @memberof Trace.Node
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trace.Node} Node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Node.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Node();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.responseName = reader.string();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 14:
                    message.originalFieldName = reader.string();
                    break;
                case 3:
                    message.type = reader.string();
                    break;
                case 13:
                    message.parentType = reader.string();
                    break;
                case 5:
                    message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.startTime = reader.uint64();
                    break;
                case 9:
                    message.endTime = reader.uint64();
                    break;
                case 11:
                    if (!(message.error && message.error.length))
                        message.error = [];
                    message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.child && message.child.length))
                        message.child = [];
                    message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Node message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trace.Node
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trace.Node} Node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Node.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Node message.
         * @function verify
         * @memberof Trace.Node
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Node.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.responseName != null && message.hasOwnProperty("responseName")) {
                properties.id = 1;
                if (!$util.isString(message.responseName))
                    return "responseName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
                if (properties.id === 1)
                    return "id: multiple values";
                properties.id = 1;
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            }
            if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
                if (!$util.isString(message.originalFieldName))
                    return "originalFieldName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.parentType != null && message.hasOwnProperty("parentType"))
                if (!$util.isString(message.parentType))
                    return "parentType: string expected";
            if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
                var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
                if (error)
                    return "cachePolicy." + error;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                if (!Array.isArray(message.error))
                    return "error: array expected";
                for (var i = 0; i < message.error.length; ++i) {
                    var error = $root.Trace.Error.verify(message.error[i]);
                    if (error)
                        return "error." + error;
                }
            }
            if (message.child != null && message.hasOwnProperty("child")) {
                if (!Array.isArray(message.child))
                    return "child: array expected";
                for (var i = 0; i < message.child.length; ++i) {
                    var error = $root.Trace.Node.verify(message.child[i]);
                    if (error)
                        return "child." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Node message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trace.Node
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trace.Node} Node
         */
        Node.fromObject = function fromObject(object) {
            if (object instanceof $root.Trace.Node)
                return object;
            var message = new $root.Trace.Node();
            if (object.responseName != null)
                message.responseName = String(object.responseName);
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.originalFieldName != null)
                message.originalFieldName = String(object.originalFieldName);
            if (object.type != null)
                message.type = String(object.type);
            if (object.parentType != null)
                message.parentType = String(object.parentType);
            if (object.cachePolicy != null) {
                if (typeof object.cachePolicy !== "object")
                    throw TypeError(".Trace.Node.cachePolicy: object expected");
                message.cachePolicy = $root.Trace.CachePolicy.fromObject(object.cachePolicy);
            }
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = true;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber(true);
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = true;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber(true);
            if (object.error) {
                if (!Array.isArray(object.error))
                    throw TypeError(".Trace.Node.error: array expected");
                message.error = [];
                for (var i = 0; i < object.error.length; ++i) {
                    if (typeof object.error[i] !== "object")
                        throw TypeError(".Trace.Node.error: object expected");
                    message.error[i] = $root.Trace.Error.fromObject(object.error[i]);
                }
            }
            if (object.child) {
                if (!Array.isArray(object.child))
                    throw TypeError(".Trace.Node.child: array expected");
                message.child = [];
                for (var i = 0; i < object.child.length; ++i) {
                    if (typeof object.child[i] !== "object")
                        throw TypeError(".Trace.Node.child: object expected");
                    message.child[i] = $root.Trace.Node.fromObject(object.child[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Node message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trace.Node
         * @static
         * @param {Trace.Node} message Node
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Node.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.error = [];
                object.child = [];
            }
            if (options.defaults) {
                object.type = "";
                object.cachePolicy = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.endTime = options.longs === String ? long.toString() : optio