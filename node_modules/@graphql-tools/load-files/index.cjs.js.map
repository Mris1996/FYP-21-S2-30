{"version":3,"file":"index.cjs.js","sources":["../../../dist/load-files/src/index.js"],"sourcesContent":["import globby, { sync as globbySync } from 'globby';\nimport unixify from 'unixify';\nimport { extname } from 'path';\nimport { statSync, readFileSync, promises as fsPromises } from 'fs';\nconst { readFile, stat } = fsPromises;\nconst DEFAULT_IGNORED_EXTENSIONS = ['spec', 'test', 'd', 'map'];\nconst DEFAULT_EXTENSIONS = ['gql', 'graphql', 'graphqls', 'ts', 'js'];\nconst DEFAULT_EXPORT_NAMES = ['schema', 'typeDef', 'typeDefs', 'resolver', 'resolvers'];\nconst DEFAULT_EXTRACT_EXPORTS_FACTORY = (exportNames) => (fileExport) => {\n    if (!fileExport) {\n        return null;\n    }\n    if (fileExport.default) {\n        for (const exportName of exportNames) {\n            if (fileExport.default[exportName]) {\n                return fileExport.default[exportName];\n            }\n        }\n        return fileExport.default;\n    }\n    for (const exportName of exportNames) {\n        if (fileExport[exportName]) {\n            return fileExport[exportName];\n        }\n    }\n    return fileExport;\n};\nfunction asArray(obj) {\n    if (obj instanceof Array) {\n        return obj;\n    }\n    else {\n        return [obj];\n    }\n}\nfunction isDirectorySync(path) {\n    try {\n        const pathStat = statSync(path);\n        return pathStat.isDirectory();\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function isDirectory(path) {\n    try {\n        const pathStat = await stat(path);\n        return pathStat.isDirectory();\n    }\n    catch (e) {\n        return false;\n    }\n}\nfunction scanForFilesSync(globStr, globOptions = {}) {\n    return globbySync(globStr, { absolute: true, ...globOptions });\n}\nfunction formatExtension(extension) {\n    return extension.charAt(0) === '.' ? extension : `.${extension}`;\n}\nfunction buildGlob(basePath, extensions, ignoredExtensions = [], recursive) {\n    const ignored = ignoredExtensions.length > 0 ? `!(${ignoredExtensions.map(e => `*${formatExtension(e)}`).join('|')})` : '*';\n    const ext = extensions.map(e => `*${formatExtension(e)}`).join('|');\n    return `${basePath}${recursive ? '/**' : ''}/${ignored}+(${ext})`;\n}\nconst LoadFilesDefaultOptions = {\n    ignoredExtensions: DEFAULT_IGNORED_EXTENSIONS,\n    extensions: DEFAULT_EXTENSIONS,\n    useRequire: false,\n    requireMethod: null,\n    globOptions: {\n        absolute: true,\n    },\n    exportNames: DEFAULT_EXPORT_NAMES,\n    recursive: true,\n    ignoreIndex: false,\n};\n/**\n * Synchronously loads files using the provided glob pattern.\n * @param pattern Glob pattern or patterns to use when loading files\n * @param options Additional options\n */\nexport function loadFilesSync(pattern, options = LoadFilesDefaultOptions) {\n    const execOptions = { ...LoadFilesDefaultOptions, ...options };\n    const relevantPaths = scanForFilesSync(asArray(pattern).map(path => isDirectorySync(path)\n        ? buildGlob(unixify(path), execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive)\n        : unixify(path)), options.globOptions);\n    const extractExports = execOptions.extractExports || DEFAULT_EXTRACT_EXPORTS_FACTORY(execOptions.exportNames);\n    const requireMethod = execOptions.requireMethod || require;\n    return relevantPaths\n        .map(path => {\n        if (!checkExtension(path, options)) {\n            return null;\n        }\n        if (isIndex(path, execOptions.extensions) && options.ignoreIndex) {\n            return false;\n        }\n        const extension = extname(path);\n        if (extension === formatExtension('js') || extension === formatExtension('ts') || execOptions.useRequire) {\n            const fileExports = requireMethod(path);\n            const extractedExport = extractExports(fileExports);\n            return extractedExport;\n        }\n        else {\n            return readFileSync(path, { encoding: 'utf-8' });\n        }\n    })\n        .filter(v => v);\n}\nasync function scanForFiles(globStr, globOptions = {}) {\n    return globby(globStr, { absolute: true, ...globOptions });\n}\nconst checkExtension = (path, { extensions, ignoredExtensions }) => {\n    if (ignoredExtensions) {\n        for (const ignoredExtension of ignoredExtensions) {\n            if (path.endsWith(formatExtension(ignoredExtension))) {\n                return false;\n            }\n        }\n    }\n    if (!extensions) {\n        return true;\n    }\n    for (const extension of extensions) {\n        const formattedExtension = formatExtension(extension);\n        if (path.endsWith(formattedExtension)) {\n            if (ignoredExtensions) {\n                for (const ignoredExtension of ignoredExtensions) {\n                    const formattedIgnoredExtension = formatExtension(ignoredExtension);\n                    if (path.endsWith(formattedIgnoredExtension + formattedExtension)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Asynchronously loads files using the provided glob pattern.\n * @param pattern Glob pattern or patterns to use when loading files\n * @param options Additional options\n */\nexport async function loadFiles(pattern, options = LoadFilesDefaultOptions) {\n    const execOptions = { ...LoadFilesDefaultOptions, ...options };\n    const relevantPaths = await scanForFiles(await Promise.all(asArray(pattern).map(async (path) => (await isDirectory(path))\n        ? buildGlob(unixify(path), execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive)\n        : unixify(path))), options.globOptions);\n    const extractExports = execOptions.extractExports || DEFAULT_EXTRACT_EXPORTS_FACTORY(execOptions.exportNames);\n    const defaultRequireMethod = (path) => import(path).catch(async () => require(path));\n    const requireMethod = execOptions.requireMethod || defaultRequireMethod;\n    return Promise.all(relevantPaths\n        .filter(path => checkExtension(path, options) && !(isIndex(path, execOptions.extensions) && options.ignoreIndex))\n        .map(async (path) => {\n        const extension = extname(path);\n        if (extension === formatExtension('js') || extension === formatExtension('ts') || execOptions.useRequire) {\n            const fileExports = await requireMethod(path);\n            const extractedExport = extractExports(fileExports);\n            return extractedExport;\n        }\n        else {\n            return readFile(path, { encoding: 'utf-8' });\n        }\n    }));\n}\nfunction isIndex(path, extensions = []) {\n    const IS_INDEX = /(\\/|\\\\)index\\.[^\\/\\\\]+$/i; // (/ or \\) AND `index.` AND (everything except \\ and /)(end of line)\n    return IS_INDEX.test(path) && extensions.some(ext => path.endsWith(formatExtension(ext)));\n}\n//# sourceMappingURL=index.js.map"],"names":["fsPromises","statSync","globbySync","path","extname","readFileSync","globby"],"mappings":"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