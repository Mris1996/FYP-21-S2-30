import { __assign, __spread, __read, __extends, __awaiter, __generator } from 'tslib';
import { GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, isSpecifiedScalarType, isScalarType, visit, Kind, TypeInfo, visitWithTypeInfo, isObjectType, isInterfaceType, isLeafType, valueFromAST, extendSchema, parse, getNullableType, BREAK, buildSchema, getIntrospectionQuery, buildClientSchema } from 'graphql';
import { applySchemaTransforms, getResponseKeyFromInfo, getErrors, mapSchema, MapperKind, renameType, visitData, visitResult, updateArgument, transformInputValue, relocatedError, getArgumentValues, valueMatchesCriteria, getDirectives, pruneSchema, selectObjectFields, appendObjectFields, modifyObjectFields, removeObjectFields, renameFieldNode } from '@graphql-tools/utils/es5';
import { isSubschemaConfig, delegateToSchema, getSubschema, handleResult, defaultMergedResolver } from '@graphql-tools/delegate/es5';
import { addResolversToSchema } from '@graphql-tools/schema/es5';

function generateProxyingResolvers(subschemaOrSubschemaConfig, transforms) {
    var _a;
    var targetSchema;
    var schemaTransforms = [];
    var createProxyingResolver;
    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {
        targetSchema = subschemaOrSubschemaConfig.schema;
        createProxyingResolver = (_a = subschemaOrSubschemaConfig.createProxyingResolver) !== null && _a !== void 0 ? _a : defaultCreateProxyingResolver;
        if (subschemaOrSubschemaConfig.transforms != null) {
            schemaTransforms = schemaTransforms.concat(subschemaOrSubschemaConfig.transforms);
        }
    }
    else {
        targetSchema = subschemaOrSubschemaConfig;
        createProxyingResolver = defaultCreateProxyingResolver;
    }
    if (transforms != null) {
        schemaTransforms = schemaTransforms.concat(transforms);
    }
    var transformedSchema = applySchemaTransforms(targetSchema, schemaTransforms);
    var operationTypes = {
        query: targetSchema.getQueryType(),
        mutation: targetSchema.getMutationType(),
        subscription: targetSchema.getSubscriptionType(),
    };
    var resolvers = {};
    Object.keys(operationTypes).forEach(function (operation) {
        var rootType = operationTypes[operation];
        if (rootType != null) {
            var typeName_1 = rootType.name;
            var fields = rootType.getFields();
            resolvers[typeName_1] = {};
            Object.keys(fields).forEach(function (fieldName) {
                var proxyingResolver = createProxyingResolver({
                    schema: subschemaOrSubschemaConfig,
                    transforms: transforms,
                    transformedSchema: transformedSchema,
                    operation: operation,
                    fieldName: fieldName,
                });
                var finalResolver = createPossiblyNestedProxyingResolver(subschemaOrSubschemaConfig, proxyingResolver);
                if (operation === 'subscription') {
                    resolvers[typeName_1][fieldName] = {
                        subscribe: finalResolver,
                        resolve: function (payload, _, __, _a) {
                            var targetFieldName = _a.fieldName;
                            return payload[targetFieldName];
                        },
                    };
                }
                else {
                    resolvers[typeName_1][fieldName] = {
                        resolve: finalResolver,
                    };
                }
            });
        }
    });
    return resolvers;
}
function createPossiblyNestedProxyingResolver(subschemaOrSubschemaConfig, proxyingResolver) {
    return function (parent, args, context, info) {
        if (parent != null) {
            var responseKey = getResponseKeyFromInfo(info);
            var errors = getErrors(parent, responseKey);
            // Check to see if the parent contains a proxied result
            if (errors != null) {
                var subschema = getSubschema(parent, responseKey);
                // If there is a proxied result from this subschema, return it
                // This can happen even for a root field when the root type ia
                // also nested as a field within a different type.
                if (subschemaOrSubschemaConfig === subschema && parent[responseKey] !== undefined) {
                    return handleResult(parent[responseKey], errors, subschema, context, info);
                }
            }
        }
        return proxyingResolver(parent, args, context, info);
    };
}
function defaultCreateProxyingResolver(_a) {
    var schema = _a.schema, operation = _a.operation, transforms = _a.transforms, transformedSchema = _a.transformedSchema;
    return function (_parent, _args, context, info) {
        return delegateToSchema({
            schema: schema,
            operation: operation,
            context: context,
            info: info,
            transforms: transforms,
            transformedSchema: transformedSchema,
        });
    };
}

function wrapSchema(subschemaOrSubschemaConfig, transforms) {
    var targetSchema;
    var schemaTransforms = [];
    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {
        targetSchema = subschemaOrSubschemaConfig.schema;
        if (subschemaOrSubschemaConfig.transforms != null) {
            schemaTransforms = schemaTransforms.concat(subschemaOrSubschemaConfig.transforms);
        }
    }
    else {
        targetSchema = subschemaOrSubschemaConfig;
    }
    if (transforms != null) {
        schemaTransforms = schemaTransforms.concat(transforms);
    }
    var proxyingResolvers = generateProxyingResolvers(subschemaOrSubschemaConfig, transforms);
    var schema = createWrappingSchema(targetSchema, proxyingResolvers);
    return applySchemaTransforms(schema, schemaTransforms);
}
function createWrappingSchema(schema, proxyingResolvers) {
    var _a;
    return mapSchema(schema, (_a = {},
        _a[MapperKind.ROOT_OBJECT] = function (type) {
            var config = type.toConfig();
            var fieldConfigMap = config.fields;
            Object.keys(fieldConfigMap).forEach(function (fieldName) {
                fieldConfigMap[fieldName] = __assign(__assign({}, fieldConfigMap[fieldName]), proxyingResolvers[type.name][fieldName]);
            });
            return new GraphQLObjectType(config);
        },
        _a[MapperKind.OBJECT_TYPE] = function (type) {
            var config = type.toConfig();
            config.isTypeOf = undefined;
            Object.keys(config.fields).forEach(function (fieldName) {
                config.fields[fieldName].resolve = defaultMergedResolver;
                config.fields[fieldName].subscribe = null;
            });
            return new GraphQLObjectType(config);
        },
        _a[MapperKind.INTERFACE_TYPE] = function (type) {
            var config = type.toConfig();
            delete config.resolveType;
            return new GraphQLInterfaceType(config);
        },
        _a[MapperKind.UNION_TYPE] = function (type) {
            var config = type.toConfig();
            delete config.resolveType;
            return new GraphQLUnionType(config);
        },
        _a));
}

var RenameTypes = /** @class */ (function () {
    function RenameTypes(renamer, options) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;
        this.renameBuiltins = renameBuiltins;
        this.renameScalars = renameScalars;
    }
    RenameTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {
                    return undefined;
                }
                if (isScalarType(type) && !_this.renameScalars) {
                    return undefined;
                }
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    return renameType(type, newName);
                }
            },
            _a[MapperKind.ROOT_OBJECT] = function () {
                return undefined;
            },
            _a));
    };
    RenameTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = visit(originalRequest.document, (_a = {},
            _a[Kind.NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return __assign(__assign({}, node), { name: {
                            kind: Kind.NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return __assign(__assign({}, originalRequest), { document: document });
    };
    RenameTypes.prototype.transformResult = function (result) {
        var _this = this;
        return __assign(__assign({}, result), { data: visitData(result.data, function (object) {
                var typeName = object === null || object === void 0 ? void 0 : object.__typename;
                if (typeName != null && typeName in _this.map) {
                    object.__typename = _this.map[typeName];
                }
                return object;
            }) });
    };
    return RenameTypes;
}());

var FilterTypes = /** @class */ (function () {
    function FilterTypes(filter) {
        this.filter = filter;
    }
    FilterTypes.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        return mapSchema(schema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (_this.filter(type)) {
                    return undefined;
                }
                return null;
            },
            _a));
    };
    return FilterTypes;
}());

var RenameRootTypes = /** @class */ (function () {
    function RenameRootTypes(renamer) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
    }
    RenameRootTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.ROOT_OBJECT] = function (type) {
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    return renameType(type, newName);
                }
            },
            _a));
    };
    RenameRootTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = visit(originalRequest.document, (_a = {},
            _a[Kind.NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return __assign(__assign({}, node), { name: {
                            kind: Kind.NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return __assign(__assign({}, originalRequest), { document: document });
    };
    RenameRootTypes.prototype.transformResult = function (result) {
        var _this = this;
        return __assign(__assign({}, result), { data: visitData(result.data, function (object) {
                var typeName = object === null || object === void 0 ? void 0 : object.__typename;
                if (typeName != null && typeName in _this.map) {
                    object.__typename = _this.map[typeName];
                }
                return object;
            }) });
    };
    return RenameRootTypes;
}());

var TransformCompositeFields = /** @class */ (function () {
    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer, dataTransformer, errorsTransformer) {
        this.fieldTransformer = fieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
        this.dataTransformer = dataTransformer;
        this.errorsTransformer = errorsTransformer;
        this.mapping = {};
    }
    TransformCompositeFields.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        this.transformedSchema = mapSchema(originalSchema, (_a = {},
            _a[MapperKind.COMPOSITE_FIELD] = function (fieldConfig, fieldName, typeName) {
                var transformedField = _this.fieldTransformer(typeName, fieldName, fieldConfig);
                if (Array.isArray(transformedField)) {
                    var newFieldName = transformedField[0];
                    if (newFieldName !== fieldName) {
                        if (!(typeName in _this.mapping)) {
                            _this.mapping[typeName] = {};
                        }
                        _this.mapping[typeName][newFieldName] = fieldName;
                    }
                }
                return transformedField;
            },
            _a));
        this.typeInfo = new TypeInfo(this.transformedSchema);
        return this.transformedSchema;
    };
    TransformCompositeFields.prototype.transformRequest = function (originalRequest, _delegationContext, transformationContext) {
        var document = originalRequest.document;
        var fragments = Object.create(null);
        document.definitions.forEach(function (def) {
            if (def.kind === Kind.FRAGMENT_DEFINITION) {
                fragments[def.name.value] = def;
            }
        });
        return __assign(__assign({}, originalRequest), { document: this.transformDocument(document, fragments, transformationContext) });
    };
    TransformCompositeFields.prototype.transformResult = function (result, _delegationContext, transformationContext) {
        var _this = this;
        if (this.dataTransformer != null) {
            result.data = visitData(result.data, function (value) { return _this.dataTransformer(value, transformationContext); });
        }
        if (this.errorsTransformer != null) {
            result.errors = this.errorsTransformer(result.errors, transformationContext);
        }
        return result;
    };
    TransformCompositeFields.prototype.transformDocument = function (document, fragments, transformationContext) {
        var _a;
        var _this = this;
        return visit(document, visitWithTypeInfo(this.typeInfo, {
            leave: (_a = {},
                _a[Kind.SELECTION_SET] = function (node) {
                    return _this.transformSelectionSet(node, _this.typeInfo, fragments, transformationContext);
                },
                _a),
        }));
    };
    TransformCompositeFields.prototype.transformSelectionSet = function (node, typeInfo, fragments, transformationContext) {
        var _this = this;
        var parentType = typeInfo.getParentType();
        if (parentType == null) {
            return undefined;
        }
        var parentTypeName = parentType.name;
        var newSelections = [];
        node.selections.forEach(function (selection) {
            var _a, _b;
            if (selection.kind !== Kind.FIELD) {
                newSelections.push(selection);
                return;
            }
            var newName = selection.name.value;
            if (_this.dataTransformer != null || _this.errorsTransformer != null) {
                newSelections.push({
                    kind: Kind.FIELD,
                    name: {
                        kind: Kind.NAME,
                        value: '__typename',
                    },
                });
            }
            var transformedSelection;
            if (_this.fieldNodeTransformer == null) {
                transformedSelection = selection;
            }
            else {
                transformedSelection = _this.fieldNodeTransformer(parentTypeName, newName, selection, fragments, transformationContext);
                transformedSelection = transformedSelection === undefined ? selection : transformedSelection;
            }
            if (transformedSelection == null) {
                return;
            }
            else if (Array.isArray(transformedSelection)) {
                newSelections = newSelections.concat(transformedSelection);
                return;
            }
            else if (transformedSelection.kind !== Kind.FIELD) {
                newSelections.push(transformedSelection);
                return;
            }
            var typeMapping = _this.mapping[parentTypeName];
            if (typeMapping == null) {
                newSelections.push(transformedSelection);
                return;
            }
            var oldName = _this.mapping[parentTypeName][newName];
            if (oldName == null) {
                newSelections.push(transformedSelection);
                return;
            }
            newSelections.push(__assign(__assign({}, transformedSelection), { name: {
                    kind: Kind.NAME,
                    value: oldName,
                }, alias: {
                    kind: Kind.NAME,
                    value: (_b = (_a = transformedSelection.alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : newName,
                } }));
        });
        return __assign(__assign({}, node), { selections: newSelections });
    };
    return TransformCompositeFields;
}());

var TransformObjectFields = /** @class */ (function () {
    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {
        this.objectFieldTransformer = objectFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformObjectFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, fieldConfig) {
            if (isObjectType(originalSchema.getType(typeName))) {
                return _this.objectFieldTransformer(typeName, fieldName, fieldConfig);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformObjectFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    TransformObjectFields.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);
    };
    return TransformObjectFields;
}());

var T