{"version":3,"file":"index.esm.js","sources":["../../../dist/resolvers-composition/src/chain-functions.js","../../../dist/resolvers-composition/src/resolvers-composition.js"],"sourcesContent":["export function chainFunctions(funcs) {\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n//# sourceMappingURL=chain-functions.js.map","import { chainFunctions } from './chain-functions';\nimport { get, set, flatten } from 'lodash';\nimport { isScalarType } from 'graphql';\nimport { asArray } from '@graphql-tools/utils';\nfunction resolveRelevantMappings(resolvers, path, allMappings) {\n    const split = path.split('.');\n    if (split.length === 2) {\n        const typeName = split[0];\n        if (isScalarType(resolvers[typeName])) {\n            return [];\n        }\n        const fieldName = split[1];\n        if (typeName === '*') {\n            return flatten(Object.keys(resolvers).map(typeName => resolveRelevantMappings(resolvers, `${typeName}.${fieldName}`, allMappings)));\n        }\n        if (fieldName === '*') {\n            return flatten(Object.keys(resolvers[typeName]).map(field => resolveRelevantMappings(resolvers, `${typeName}.${field}`, allMappings))).filter(mapItem => !allMappings[mapItem]);\n        }\n        else {\n            const paths = [];\n            if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n                if (resolvers[typeName][fieldName].subscribe) {\n                    paths.push(path + '.subscribe');\n                }\n                if (resolvers[typeName][fieldName].resolve) {\n                    paths.push(path + '.resolve');\n                }\n                if (typeof resolvers[typeName][fieldName] === 'function') {\n                    paths.push(path);\n                }\n            }\n            return paths;\n        }\n    }\n    else if (split.length === 1) {\n        const typeName = split[0];\n        return flatten(Object.keys(resolvers[typeName]).map(fieldName =>